

# DAY 9

## 7장 수업내용

- 인터페이스

  - 용도 : 사용자(User)와 제공자(Provider) 중간 매개체(연결) 역활

    - 사용자와 제공자 간의 상속이 없음에도 가능.

  - 구성요소 : public static final 상수 속성 ,abstract 메서드 , static 메서드 ,default 메서드

    - abstract 메서드는 구현 body 없다.

      '~();'

    - static과 default는 구현 body있다.

    - '~(){}'

  - 설계시, 서로 다른 시스템을 통합할때 표준화를 위해서 활용

  - 클래스는 일원화된 구조(선언+구현)

  - 인터페이스는 이원화된 구조(선언) , 그래서 구현 클래스가 있어야 한다.

  - public interface 이름 [extends 인터페이스, 인터페이스.....] (인터페이스는 인터페이스만 상속 가능,다중상속 가능)

    - public class 이름 implements 인터페이스, 인터페이스....{}

  - 인터페이스는 reference 변수(객체명) 타입으로 선언 가능하다.

  - 인터페이스는 new를 사용해서 객체 생성 가능하려면 구현한 클래스로 객체 생성해야한다.

    (다형성객체)

- abstract 

  - (추상, 구현이 없고, 선언만 존재한다.)-클래스, 메서드
  - 일반적으로 abstract메서드는 클래스 설계시 모든 자식 클래스의 공통 기능을
  - abstract 메서드는 상속 받은 자식 클래스에서 반드시 override해서 구현 body를 정의해야만 객체 생성이 가능하다.
  - abstract 클래스는 new 사용해서 인스턴스(객체) 생성 불가능 .
    - abstract메서드가 선언되어 있는 클래스 또는 객체 생성 못하게 클래스 설계할 때 사용
  - abstract 메서드가 정의되어 있지 않아도 클래스를 abstract 라고 선언할 수 있다. (객체생성 못하게 하기 위해서)

​	

## 8장 예외처리

프로그램 오류는 컴파일 에러와 런타임 에러가 있다.

컴파일 에러(compile error)- 컴파일 할때 나타나는 에러

- 문법적 문제, 언어 규칙에 맞지 않는 문제

런타임 에러(runtime error)- 실행중 발생하는 에러

- 실행시 발생되는 오류로 논류 오류와 로직 오류가 있다.

- 논리적 에러-실행은 되지만 의도와 다르게 동작.

- 런타임 에러는 또 에러와 예외 두가지로 구분

  1.에러(XXXError)- 수습될 수 없는 심각한 오류, 프로그램적으로 수정할 수 없다.

  2.예외- 다소 미약한 오류

  - 예외중 RuntimeException클래스-프로그램의 실수로 발생하는 예외
  
  - 예외중 Exception클래스(runtimeExceptin의 하위 클래스) -사용자의 실수와 같은 외적 요인에 의한 예외

예외처리 방법 (declare,handle)

- 예외 발생-declare,handle
- 예외 발생 -throw new 발생시킬예외클래스 생성자()
- 사용자 정의 Exception 정의, 생성, 사용
  1. 예외 처리(declare)-throw
  2. 예외 처리(handle)- try~catch~finally

자바의 Exception

- Checked Exeception - 실행 범위가 JRE를 벗어나느 경우로 범위 이상의 에러 임으로 미리 알려준다.(처리 가능 외의 오류, I/o, network,DB등)  declare나 handle 둘 중 하나로 처리
  
- IOException, Socket, 
  
- unchecked exception- 실행 범위가 JRE를 벗어나지 않고, 사용자 부주의, 또는 논리 오류에 의해서 발생될 수 있는 Exception

  - NullPointerException(객체 생성않고 메서드 호출시,가장 많다.), ArrayInddexOutOfBoundsException, NumberFormatException등

  

declare방식

- throws 예외클래스이름을  메서드 선언부에 선언한다. 예외처리 대신에 메서드를 호출한 곳으로 예외처리를 떠 넘긴다.(즉 해결하는 것이 아니다.)
- handle 
  - try~catch~finally



예외클래스의 상속 계층 구조

- catch가 여러번 선언될 경우, 예외 클래스의  상속 계층구조의 역순으로 구체적인 예외클래스타입부터 선언해준다. 즉 큰 오류부터 작성하면 작은 오류를 잡지 못한다.

```java
try~catch~finally
try~finally
try~catch(0or M)

try{
 //예외 발생 가능성 문장;
문장;
}catch(예외클래스타입 객체){
	//예외처리 문장
}catch(예외클래스타입 객체){
	//예외처리 문장
}finally{//try~catch문장만 와도 된다.finally은 추가사항
	//예외 발생과 무관한 반드시 수행해야 할 문장;
    //ex)사용했었던 resource들의 정리  .close()코드문장=>예외가 발생하면 checed exception 되며 try~catch~(finally) 사용가능.
}
```

- 프로그램  구현시 의도적으로  예외를 발생시켜서 호출한쪽(caller)에게 메세지를 전달해서 호출한 쪽(caller)에서 흐름을 제어할 수 있도록  throw new 예외클래스(메세지) 처리한다.

- API에서 
  - java.lang.Throwable(최상위클래스) -java.lang.Error, -java.lang.Exception 

```java
public class 짝수홀수 {

	public static void main(String[] args) {
		System.out.println("main start");
		int num =-1;
		try {
		num =Integer.parseInt(args[0]);
		System.out.println("other statement processing...");
		}catch(ArrayIndexOutOfBoundsException e) {
			System.out.println("배열관련예외처리");
		}catch(NumberFormatException e) {
			System.out.println("숫자 형식관련 예외 처리");
		}catch(Exception e) {
			e.printStackTrace();//보안관련 실제로는 삭제하는게 좋다
			System.out.println(e.getMessage());
		}finally {
			System.out.println("resource 정리");
		}
		if(num%2==0&& num>0) {
			System.out.println(args[0]+"짝수입니다.");
		}else if(num%2==1 && num>0){
			System.out.println(args[0]+"홀수입니다.");
		}

		System.out.println("main end");
	}

```

Run configuation 하고 'a'를 넣게 되면 숫자 형식 관련 예외 처리에 걸리므로 "숫자형식 관련 예외"가 출력되어야 하며 finally는 무조건 실행이므로'' resource정리'' 가 나오고 if, else if 구문은 해당이 없기에 넘어간다.

결과는 

`main start
숫자 형식관련 예외 처리
resource 정리
main end`

사용자정의 예외 클래스

- 사용자 정의 예외 클래스를 정의할때는 구체적인 예외 처리 관련 API의 Excetion  속성과 메서드를 추가해서 만든다.

- 사용자 정의 예외 클래스를 정의할때 Eeception을 상속을 받아서 예외처리에 필요한 속성과 메서드를 추가해서 만든다.

```java
public class XXXException extends Exception {//클래스 이름 끝에 Exception을 추가해 명시적으로 하자. Exception은 구체적으로(API)에서 사용하는 것을 하자.
    //속성
    //생성자
    //멤버 메서드
}
```

```java
public class ExceptionHandleTest {
    
	public void checkTall(double tall) throws AbnormalValueException {
		//중학생 키 범위가 140이상 180이하 여부를 체크해서
		//범위가 아니면예외를 던집니다
        
		if(tall<140) throw new AbnormalValueException("140보다 작습니다");
		if(tall>180) throw new AbnormalValueException("180보다 큽니다");
	}
	
	public static void main(String[] args) {
		double[] talls = new double[] { 155.5,163.2,170.4,149.5,
				128,168,189.5,166,172,169,158,173};
		ExceptionHandleTest  test = new ExceptionHandleTest();
        //키값의 범위를 체크해서
		//예외 발생하면 예외처리합니다. => 작년도 키 평균값으로 보정합니다.
		//올해의 중학생 평균 키값을 출력합니다.
		for(int i=0;i<talls.length;i++) {
			try {
			     test.checkTall(talls[i]);
			}catch(AbnormalValueException e) {
				System.out.println(e.getMessage()+", 작년도 키값으로 보정합니다.");
				talls[i] = e.getOldTall();				
			}
		}
		double hap = 0.0;
		for(double tall : talls)
			hap += tall;
		System.out.println("올해 중학생 평균 키는 "+(hap/talls.length)+"cm입니다.");
		
		}//main end

}//class 
```

```java
public class AbnormalValueException extends Exception {
	private double oldTall = 161.2;

	public AbnormalValueException(String message) {
		super(message);
	}
	public double getOldTall() {
		return oldTall;
	}
	}
```

위의 문제로 복습해 보자.



# Day10

## java.lang

- equals(Object obj)

  - 객체가 생성된 주소의 헤시값을 비교한다.

    

``` java
v2=v1;
//v1==v2 -> 0x1234==0x2345 -> false
v1.equals(v2);
//v1==v2 -> 0x1234==0x1234 -> true
```

hashCode()

- 해싱 기법에 사용되는 해시함수를 구현한 거승로 다량의 데이터를 저장하고 검색하는데 유용.
- `hashCode()`객체 생성 주소의 hash값 리턴
- String클래스는 문자열의 내용이 같으면, 동일한 해시코드를 반환하도록 hashCode메서드가 오버라이딩 되기 때문에 항상 동일한 해시코드값을 얻는다.

```java
public static void main(String[] args){
String str1= new String("abs");
String str2= new String("abs");

    System.out.println(Str1.equlas(str2));//내용비교 true
    System.out.println(str1.hashCode());//
    System.out.println(str2.hashCode());
    System.out.println(System.identityHashCode(str1));
    System.out.println(System.identityHashCode(str2));
}
```



clone()

- `implements Cloneable` 를 꼭 해야 clone() 호출이 가능하다.
- 객체 복제 한다. `객체.clone()` 

얕은 복사 깊은 복사

- 얕은 복사 -객체의 생성된 주소값을 할당하여 있는 값을 이용(값이 바뀌면 같이 바뀐다.)
- 깊은 복사-객체의 모든 속성을 새로 생성하여 메모리에 새로운 객체로 생성

```java
import java.util.*;


class Circle implements Cloneable{
	Point p;
	double r;
	Circle(Point p,double r){
		this.p=p;
		this.r=r;
	}
	public Circle shallowCopy() {//얕은 복사 point때문에 얕은 복사만 된다.
		Object obj=null;
		try {
			obj=super.clone();
			
		}catch(CloneNotSupportedException e) {}
		 return (Circle)obj;
		}
	public Circle deepCopy() {// 깊은 복사 그래서 point를 다시 정의해준다.
		Object obj=null;
		try {
			obj=super.clone();
		}catch(CloneNotSupportedException e) {}
		Circle c = (Circle)obj;
		c.p=new Point(this.p.x, this.p.y);
		return c;
	}
	public String toString() {
		return "[p="+p+",r="+r+"]";
	}
}
class Point{
	int x,y;
	Point (int x,int y){
		this.x=x;
		this.y=y;
	}
	public String toString() {
		return "("+x +", "+y+")";
	}
}

public class ShallowDeepCopy {

	public static void main(String[] args) {
		Circle c1= new Circle(new Point(1,1),2.0);
		Circle c2=c1.shallowCopy();
		Circle c3=c1.deepCopy();
		
		System.out.println("c1="+c1);
		System.out.println("c2="+c2);
		System.out.println("c3="+c3);

		 c1.p.x=9;
		 c1.p.y=9;
		 System.out.println("=c1의 변경 후=");
		 System.out.println("c1="+c1);
		 System.out.println("c2="+c2);
		 System.out.println("c3="+c3);
	}
}
/*c1=[p=(1, 1),r=2.0]
c2=[p=(1, 1),r=2.0]
c3=[p=(1, 1),r=2.0]
=c1의 변경 후=
c1=[p=(9, 9),r=2.0]
c2=[p=(9, 9),r=2.0]
c3=[p=(1, 1),r=2.0]*/ //결과값
```

Class객체를 얻는 방법

`class cObj=new Card().getClass();`생성된 객체로 얻는 방법

`class cObj=Card.class;`클래스 리터럴(*.class)로부터 얻는 방법

`class cObj=Class.forName("Card");`클래스 이름으로 부터 얻는 방법

class 객체를 통한 객체 생성 메서드 호출

`Card c= new Card();`new 연산자를 이용한 객체 생성

`Card c= Card.class.newInstance();`Class객체를 이용해서 객체 생성



String클래스((Object 의 toString)

- 변경 불가능한 클래스
- new 없으면 문자저장 장소 pull(?)에 저장 되므로 

```java
String str1="abs";
String str2="abs";
str==str2 ->ture
str1.equals(str2) ->ture

String str3=new String("abs");
String str4=new String("abs");
str3 ==str4 ->false //주소비교
str3.equals(str4) ->true //내용비교
```

join()과 StringJoiner

- 여러 문자열 사이에 구분자를 넣어서 결합

유니코드의 보충문자

- 매개변수의 타입이 char일 것 같은데 int인 것은 확장된 유니코드를 다루기 위함이다.
- 'int ch'는 보충문자 지원 한것, 'char ch'는 지원하지 않은 것이다.

String.format()

- 형식화된 문자열을 만드는 것으로 printf()와 사용법이 완전이 같다.

기본값 String 전환,String을 기본값으로 변환

- String.String.valueOf(boolean b)
  - char , int , float, double 가능
  - 또는 +"문자열" 하면 문자화 된다.
- Boolean.paraseBoolean(String s)
  - byte, short, int , long,float, double가능

StirngBuffer클래스, StringBuilder 클래스

- StringBuffer클래스는 변경이 가능하다.
- 멀티쓰레드에 안전하도록 동기화 되어 있다. (예를 들어 여러 사람이 집을 짓는 것과 같으며 장비를 한사람만 사용할 수 있도록 감독하는 것이다.)
- StringBuilder는 StringBuffer에서 생성자만 바꾸면 된다.

Math클래스

- 접근 제어자가 private이기 때문에 다른 클래스에서 Math인스턴스 생성 불가다.
- Math클래스의 메서드는 모두 static이다.(객체 생성없이 사용하기 위해)
- Exact포함된 메서드들은 JDK1.8부터 새로 추가 되었으며, 정수형 연산에서 발생 가능한 오버플로우를 감지한다
  -  int addExact(int x, int y) int subtractExact(int x, int y) 등

StrictMath클래스

- Math클래스는 Os에 의존적인 계산을 하면 자바 작성 프로그램임에도 컴퓨터마다 결과같이 다를 수 있기 때문에 StrictMath클래스를 이용하여 이러한 차이를 없앤다.

래퍼(wrapper)클래스

- 기본값을 객체로 다루기 위해 사용하는 것으로
- boolean - Boolean
- char - Character
- byte-Byte
- short-Short
- int - Integer
- long-Long
- float-Float
- double-Double
- 래퍼 클래스들은 모두 equals()가 오버라이딩 되어 있어 주소값이 아닌 객체가 가지고 있는 값을 비교한다.

오토박싱&언박싱

- 기본형과 참조형 간의 덧셈이 가능하다.

## 유용한 클래스

- Object의 equals() - 객체 생성 주소의 hash값을 비교
  hashCode() - 객체 생성 주소의 hash값 리턴

- Object obj = new Double();
  실제 생성된 객체의 타입을 리턴받으려면...getClass()

- Object의 toString() - 클래스 FullName@hash값

- 일반 메서드에서는 notify(),notifyAll(),wait()호출 불가, synchronized가 선언된 메서드에서 호출가능 => 멀티 스레드 환경에서

```java
java.lang.String -문자열 표현,불변객체
String s=new String(new byte[]{65,66,67})
    system.out.println(s);//System.out.println(s.toString())와 동일. ABC로 출력
String s2="java";
byte[] bytes= s2.getBytes();//각 소문자의 유니코드값 합산값이 결과다.
s2.charAt(0);//문자열 하나 추출
s2.substring(1,3);// av 가 나온다(3전까지 나온다.), -값으로 하면 뒤에서부터 가능
s.concat(s2); //s객체 출력하면 "ABC"--S는 불변객체이기 떄문이다. 새로운 문자열로 저장되기 때문에 s3?로 저장할시 그것이 "ABCjava"가 나온다.
contains();

문자열객체.equlas(비교할 문자열객체)-String의 equlas는 문자열 내용만 비교한다
equalslgnoreCase();//대문자 소문자 무시!
s2.length();//문자열의 길이를 리턴한다.
String s3="JackAndJue"
    s3.replace("J","B1")=> s3객체 출력하면"JackAndJue"
    String s4=s3.replace("J","B1");=>"BlackAndBlue"
    s3="   Jack  Jus   ";
s3.trim().length();==>결과?9 
    primitive data type 을 문자열로 변환하려면 String.valueOf() 또는 값+"문자열"
    split(구분자 또는 정규표현식)-문자열을 구분자로 쪼개어 문자열 매열로
    join(결합문자, 문자열배열)//하나의 문자열로 리턴을 하게된다.문자열 배열 요소를 결합문자를 사용해서 하나의 결합된 문자열로
    가변문자열은 StringBuffer 사용
    equlas()//주의해야한다
    StringBuffer sb1=new StringBuffer("java");
	StringBuffer sb2=new StringBuffer("java");
	System.out.println(sb1.equals(sb2));//결과는 false
sb1.append("& sql")://ab1의 출력내용은 java& squl 
sb1.insert(4, " web ");//위치 지정후 내용 삽입
remove();//문자열 제거
length();
substring();
```

수학계산에 유용한 메서드를 가지고 있는 클래스 

- java.lang.Math

- 생성자 private이므로 new Math() **X** (안된다)

- 모든 속성과 메서드는 static

  ```java
  abs()
  max()
  min()
  log()
  power()
  sqrt()
  round()
  ceil()
  floor()
  cos()
  ... 다양하다
  ```

모두 객체로 구현해야 할 경우, primitive data type을 객체로 wrapping

boolean - Boolean-booleanValue()

byte- Byte-byteValue()   문자열을 다시 Boolean.parseBoolean 

short-Short-shortValue()

int -Integer-intValue()

char-Character-charValue()

float-Float-floatValue()

double-Double -doubleValue()

- 객체가 null인지 아닌지 체크하거나 반드시 null아님을 확정해야 할때 제공해주는 클래스는
  - java.util.objects클래스에 isNull() 반대는 nonNull()
  - 동일 클래스에 compare()는 두 비교대상이 같으면 0, 크면 양수, 작으면 음수

시스템의 현재 시간을 utc기준 milli second로 리턴하는 메서드 System.currentTimeMillis()

- 1970? 년때부터의 시간 누적 계산

```java
public static void main(String[] args) {
	
		System.currentTimeMillis();
		System.out.println("우리에게는 시간이 없다.");
		System.out.println(System.currentTimeMillis());	
}
}
//결과값
/*우리에게는 시간이 없다.
1559004993821*/ 
```

난수 생성

- Math.random()
  - Random r= new Random() 

```java
Random r= new Random() 
(int)(Math.random()*100+1)//int 는 소수점을 없애기 위함
r.nextlnt(100)+1;
Random r= new Random(seed값)//난수값을 같게 하기위해서 
    //원래는 시간에 따라 난수가 달라지지만 seed값이 같으면 같은 난수가 생긴다.
```

정규표현식을 이용해서 데이터 처리 경우, 특정 패턴을 객체로 생성

- java.util.regex.Pattern 클래스의 compile("패턴") => Pattern객체 생성(인스턴스 생성) ,new로 생성안한다
- Matcher m=Pattern 인스턴스.matcher(처리할 대상 데이터) =>Matcher객체 생성 ,new로 생성 안한다.
- 실제 비교를 하기위해서는 m.matches()=>true  of false 리턴
  - .하나의 모든 문자
  - [a-zA-Z0-9] 범위
  - en$ 로 끝나야한다
  - ^ab not의 의미
  - [0-9]? zero or noe
  - [0-9]+ one or more
  - [0-9]* zero or more
  - {2.5}최소횟수, 회대횟수
  - `\\d` ...?

표준 출력

- java.io.lnputStream 바이트 최상위 스트림은 추상클래스이며

  System.in운영체제에 맞게 Inputstream 구현 객체

- 1.5버전 이전에 한글 키보드 입력 받으려면 1바이트를 2바이트로(한글을 크다)
  - 문자 스트림은 XXXXReader, XXXWriter

```java
try{
BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
    String s=br.readLine();
    //Integer.parseInt(s)
}catch(IOException e){
    
}finally{
    try{}
    br.close();
	}catch(IOException e){
    
}
}
```



Scanner 

```java
Scanner scan= new Scanner (System.in)
scan.next();
scan.nextLine();
scan.nextInt();
......
```

1.6버전 추가 System.console() //이클립스에서는 동작하지 않는다.

# Day 11

## 날짜



- getInstance()를 통해 얻은 인스턴스는 기본적으로 현재 시스템의 날짜와 시간에 대한 정보를 담는다.
- 원하는 날짜나 시간을 설정하려면 set메서드를 사용하면 된다.

```javascript
public class CalendarEx2 {

	public static void main(String[] args) {
		//요일은 1부터 시작이므로 DAY_OF_WEEK[0]은 비운다
		final String[] DAY_OF_WEEK= {"","일","월","화","수","목","금","토"};
		
		Calendar date1=Calendar.getInstance();
		Calendar date2=Calendar.getInstance();
		
		date1.set(2019,5,28);
		System.out.println("date1은 "+ toString(date1)
		+DAY_OF_WEEK[date1.get(Calendar.DAY_OF_WEEK)]+"요일이고,");
		System.out.println(toString(date1));
		System.out.println("date2은 "+ toString(date2)
		+DAY_OF_WEEK[date2.get(Calendar.DAY_OF_WEEK)]+"요일이고,");
		
		long difference =
				(date2.getTimeInMillis()-date1.getTimeInMillis())/1000;
		//천분의 1로 단위변환을 해야한다.
		System.out.println("date1 (date1)부터 date2(date2)까지"
			+ difference+"초가 지났다.");
		System.out.println("일 (day)로 계산하면"
				+ difference/(24*60*60)+"일이다");
		//1일은 24*60*60이다.
		}
	public static String toString(Calendar date) {
		return date.get(Calendar.YEAR)+"년 "+(date.get(Calendar.MONTH)+1)
				+"월 "+ date.get(Calendar.DATE) +"일 ";
	}

```

```java
public class CalendarEx3 {

	public static void main(String[] args) {
		final int[] TIME_UNIT = {3600,60,1};//큰단위를 앞에
		final String[] TIME_UNIT_NAME= {"시간","분","초"};
		
		Calendar time1= Calendar.getInstance();
		Calendar time2= Calendar.getInstance();
		
		time1.set(Calendar.HOUR_OF_DAY,10);
		time1.set(Calendar.MINUTE,20);
		time1.set(Calendar.SECOND,30);
		
		time2.set(Calendar.HOUR_OF_DAY,20);
		time2.set(Calendar.MINUTE,30);
		time2.set(Calendar.SECOND,10);
		
		System.out.println("time1:"+time1.get(Calendar.HOUR_OF_DAY)+"시"
				+time1.get(Calendar.MINUTE)+"분  "+time1.get(Calendar.SECOND)+"초");
		System.out.println("time2:"+time2.get(Calendar.HOUR_OF_DAY)+"시"
				+time2.get(Calendar.MINUTE)+"분  "+time2.get(Calendar.SECOND)+"초");
		long difference=
				Math.abs(time2.getTimeInMillis()-time1.getTimeInMillis())/1000;
		System.out.println("time1과 time2의 차이는"+difference+"초 입니다.");
		String tmp="";
		for(int i=0;i<TIME_UNIT.length;i++) {
			tmp+= difference/TIME_UNIT[i]+TIME_UNIT_NAME[i];
			difference %=TIME_UNIT[i];
		}
		System.out.println("시분초로 변환하면"+tmp+"입니다.");
		

	}

}
```

```java
public class CalendarEx4 {

	public static void main(String[] args) {
		Calendar date=Calendar.getInstance();
		date.set(2018,9,3); 
		System.out.println(toString(date));
		System.out.println("=1일 후=");
		date.add(Calendar.DATE, 1);
		System.out.println(toString(date));
		
		System.out.println("=6달 전=");
		date.add(Calendar.MONTH, -6 );
		System.out.println(toString(date));
		
		System.out.println("=31일 후(roll)=");
		date.roll(Calendar.DATE, 31);
		System.out.println(toString(date));
		System.out.println("=31일 후(add)=");
		date.add(Calendar.DATE,31 );
		System.out.println(toString(date));
		

	}
	public static String toString(Calendar date) {
		return date.get(Calendar.YEAR)+"년 "+(date.get(Calendar.MONTH)+1)
				+"월  "+date.get(Calendar.DATE)+"일";
	}

}
```

## 

## DecimalFormat

```java
import java.text.DecimalFormat;//import해야한다.
public class DecimalFrmat연습 {

	public static void main(String[] args) {
		double number=1234567.89;
		String[] pattern= {
				"#",
				"0",
				"0.0",
				"#.#",
				"#E0",
				"0.000000E0",
				"#.######E0",//E뒤에는 꼭 0을 써주어야 한다.
				"#,###.##+;#,###.##-"//양수 음수 구분
				
		};
		for(int i=0;i<pattern.length;i++) {
			DecimalFormat df =new DecimalFormat(pattern[i]);
			System.out.printf("%19s:%s\n",pattern[i],df.format(number));
		}
	}

}

```



## SimpleDateFormat

```java
import java.text.SimpleDateFormat;
import java.util.Date;//import해야한다.
public class DateFormat연습 {

	public static void main(String[] args) {
		Date today=new Date();
		
		SimpleDateFormat sdf1,sdf2,sdf3,sdf4;
		
		sdf1=new SimpleDateFormat("yyyy-MM-DD");
		sdf2=new SimpleDateFormat("HH:mm:ss.SSS");
		sdf3=new SimpleDateFormat("D번째 날");
		sdf4=new SimpleDateFormat("W번째 주");
		
		System.out.println(sdf1.format(today));
		System.out.println(sdf2.format(today));
		System.out.println(sdf3.format(today));
		System.out.println(sdf4.format(today));
	}
}
//결과
/*2019-05-148
11:39:14.259
148번째 날
5번째 주*/
```

| G    | 연대(BC.AD)                            | AD                |
| ---- | -------------------------------------- | ----------------- |
| y    | 년도                                   | 2006              |
| M    | 월(1~12 또는 1월~12월)                 | 10 또는 10월, OCT |
| w    | 년의 몇 번째 주(1~53)                  | 50                |
| W    | 월의 몇 번째 주(1~5)                   | 4                 |
| D    | 년의 몇 번째 일(1~366)                 | 100               |
| d    | 월의 몇 번째 일(1~31)                  | 15                |
| F    | 월의 몇 번째 요일(1~5)                 | 1                 |
| E    | 요일                                   | 월                |
| a    | 오전/오후(AM,PM)                       | PM                |
| H    | 시간(0~23)                             | 20                |
| k    | 시간(1~24)                             | 13                |
| K    | 시간(0~11)                             | 10                |
| h    | 시간 (1~12)                            | 11                |
| m    | 분(0~59)                               | 35                |
| s    | 초(0~59)                               | 55                |
| S    | 천분의 일초(0~999)                     | 253               |
| z    | Time zone(General time zone)           | GMT+9:00          |
| Z    | TIme zone(RFC 822 time zone)           | +0900             |
| `    | escape문자(특수문자를 표현하는데 사용) | 없음ㄴ            |



## 날짜 출력형식 변환

```java
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateFormat연습2 {

	public static void main(String[] args) {
		DateFormat df=new SimpleDateFormat("yyyy년 MM월 dd일 HH시 mm분 ss초");
		DateFormat df2=new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
		try {
			Date d=df.parse("2019년 5월 27일 11시 20분 10초");
			System.out.println(df2.format(d));
			Date d1=df.parse("2019년 5월 28일 12시 50분 60초");
			System.out.println(df2.format(d1));
		}catch(Exception e) {}
	}
}//변환을 위해서 .parse를 사용한다.
```

